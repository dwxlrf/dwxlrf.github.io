import{_ as i,c as e,a2 as t,o as r}from"./chunks/framework.C890iunk.js";const l="/vitepress/assets/image-20241014214646779.DN21CXri.png",d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"spring/分布式消息框架RabbitMQ-.md","filePath":"spring/分布式消息框架RabbitMQ-.md"}'),o={name:"spring/分布式消息框架RabbitMQ-.md"};function b(s,a,n,h,u,p){return r(),e("div",null,a[0]||(a[0]=[t('<h2 id="_1-什么是rabbitmq" tabindex="-1">1.什么是RabbitMQ <a class="header-anchor" href="#_1-什么是rabbitmq" aria-label="Permalink to &quot;1.什么是RabbitMQ&quot;">​</a></h2><p>[<em><strong>官网</strong></em>](<a href="https://spring.io/projects/spring-amqp/" target="_blank" rel="noreferrer">Spring AMQP</a>)</p><p>理解RabbitMQ前我们先认识三个概念：生产者、消费者、代理</p><p>没错，RabbitMQ就是最特殊的那个---代理，可以把RabbitMQ想象为一个拍卖员，生产者委托卖货，消费者出钱买货，而代理则作为拍卖行。当然，我们是不会抽取手续费滴，当代活雷锋。我们最大的使命是让双方都满意！</p><h2 id="_2-rabbitmq运作模式" tabindex="-1">2.RabbitMQ运作模式 <a class="header-anchor" href="#_2-rabbitmq运作模式" aria-label="Permalink to &quot;2.RabbitMQ运作模式&quot;">​</a></h2><p><code>执行运作前先绑定（Binding），就是一套规则，为整体的操作做前置准备</code></p><p>看图前先介绍一下各方代表：</p><ul><li>Publisher：生产者</li><li>Consumer：消费者</li><li>Virtual host：本质为一个RabbitMQ服务器 <ul><li>Exchange：交换器。相当于服务器中的组件，用于操作数据</li><li>Queue：队列。存储运送的信息</li></ul></li></ul><p><img src="'+l+'" alt="image-20241014214646779"></p><h2 id="_3-rabbitmq的五种运行模式" tabindex="-1">3.RabbitMQ的五种运行模式 <a class="header-anchor" href="#_3-rabbitmq的五种运行模式" aria-label="Permalink to &quot;3.RabbitMQ的五种运行模式&quot;">​</a></h2><ol><li><h3 id="简单模式-simple-一个生产者-一个消费者" tabindex="-1">简单模式（Simple）：一个生产者，一个消费者 <a class="header-anchor" href="#简单模式-simple-一个生产者-一个消费者" aria-label="Permalink to &quot;简单模式（Simple）：一个生产者，一个消费者&quot;">​</a></h3><p>最简单的消息模式，一个生产者，一个消费者和一个队列，生产者向队列里发送消息，消息者从队列中获取消息并消费</p></li><li><h3 id="工作队列模式-work-queue-多个消费者竞争消息" tabindex="-1">工作队列模式（Work Queue）： 多个消费者竞争消息 <a class="header-anchor" href="#工作队列模式-work-queue-多个消费者竞争消息" aria-label="Permalink to &quot;工作队列模式（Work Queue）： 多个消费者竞争消息&quot;">​</a></h3></li><li><h3 id="发布-订阅模式-publish-subscribe-一个生产者-多个消费者" tabindex="-1">发布/订阅模式（Publish/Subscribe）：一个生产者，多个消费者 <a class="header-anchor" href="#发布-订阅模式-publish-subscribe-一个生产者-多个消费者" aria-label="Permalink to &quot;发布/订阅模式（Publish/Subscribe）：一个生产者，多个消费者&quot;">​</a></h3></li><li><h3 id="路由模式-routing-根据路由键将消息转发到对应队列" tabindex="-1">路由模式（Routing）：根据路由键将消息转发到对应队列 <a class="header-anchor" href="#路由模式-routing-根据路由键将消息转发到对应队列" aria-label="Permalink to &quot;路由模式（Routing）：根据路由键将消息转发到对应队列&quot;">​</a></h3></li><li><h3 id="通配符模式-topics-使用通配符匹配路由键" tabindex="-1">通配符模式（Topics）：使用通配符匹配路由键 <a class="header-anchor" href="#通配符模式-topics-使用通配符匹配路由键" aria-label="Permalink to &quot;通配符模式（Topics）：使用通配符匹配路由键&quot;">​</a></h3></li></ol>',11)]))}const m=i(o,[["render",b]]);export{d as __pageData,m as default};
