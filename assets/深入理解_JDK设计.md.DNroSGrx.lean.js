import{_ as i,c as a,a2 as t,o as n}from"./chunks/framework.DPuwY6B9.js";const g=JSON.parse('{"title":"JDK基础至原理深入理解","description":"","frontmatter":{},"headers":[],"relativePath":"深入理解/JDK设计.md","filePath":"深入理解/JDK设计.md"}'),l={name:"深入理解/JDK设计.md"};function e(h,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="jdk基础至原理深入理解" tabindex="-1">JDK基础至原理深入理解 <a class="header-anchor" href="#jdk基础至原理深入理解" aria-label="Permalink to &quot;JDK基础至原理深入理解&quot;">​</a></h1><h2 id="jdk设计思想" tabindex="-1">JDK设计思想 <a class="header-anchor" href="#jdk设计思想" aria-label="Permalink to &quot;JDK设计思想&quot;">​</a></h2><p>JDK（Java Development Kit）的设计思想贯穿了整个Java生态的底层逻辑，它不仅是一套开发工具包，更是<strong>面向对象工程化、跨平台兼容、高可扩展性</strong>的设计典范。以下是其核心设计思想的系统梳理：</p><h3 id="_1-跨平台-一次编写-到处运行-wora" tabindex="-1">1. <strong>跨平台：一次编写，到处运行（WORA）</strong> <a class="header-anchor" href="#_1-跨平台-一次编写-到处运行-wora" aria-label="Permalink to &quot;1. **跨平台：一次编写，到处运行（WORA）**&quot;">​</a></h3><p>这是Java的立身之本，也是JDK最核心的设计目标。</p><ul><li><strong>核心逻辑</strong>：通过JVM（Java虚拟机）的字节码抽象层，屏蔽不同操作系统的底层差异。</li><li><strong>JDK体现</strong>：Java源码编译为与平台无关的<code>.class</code>字节码，由各平台的JVM负责解释执行。</li><li><strong>典型例子</strong>：同一个Java程序无需重新编译，即可在Windows、Linux、macOS等系统上运行。</li></ul><h3 id="_2-纯面向对象-接口驱动-分层抽象" tabindex="-1">2. <strong>纯面向对象：接口驱动 + 分层抽象</strong> <a class="header-anchor" href="#_2-纯面向对象-接口驱动-分层抽象" aria-label="Permalink to &quot;2. **纯面向对象：接口驱动 + 分层抽象**&quot;">​</a></h3><p>JDK彻底贯彻了面向对象的封装、继承、多态思想，并通过<strong>接口与实现分离</strong>实现了高度解耦。</p><ul><li><strong>核心逻辑</strong>：用接口定义行为契约，用抽象类提供通用实现，用具体类专注底层细节。</li><li><strong>JDK体现</strong>： <ul><li>集合框架：<code>Collection</code>（根接口）→ <code>List</code>/<code>Set</code>（子接口）→ <code>AbstractCollection</code>/<code>AbstractList</code>（抽象类）→ <code>ArrayList</code>/<code>LinkedList</code>（具体实现）。</li><li>IO流体系：<code>InputStream</code>/<code>OutputStream</code>（根接口）→ <code>FileInputStream</code>（节点流）→ <code>BufferedInputStream</code>（处理流）。</li></ul></li><li><strong>设计价值</strong>：职责分层清晰，便于扩展和替换实现（如用<code>LinkedList</code>替换<code>ArrayList</code>无需修改上层代码）。</li></ul><h3 id="_3-开闭原则-对扩展开放-对修改关闭" tabindex="-1">3. <strong>开闭原则：对扩展开放，对修改关闭</strong> <a class="header-anchor" href="#_3-开闭原则-对扩展开放-对修改关闭" aria-label="Permalink to &quot;3. **开闭原则：对扩展开放，对修改关闭**&quot;">​</a></h3><p>这是面向对象设计的核心原则，JDK通过多种机制保证了系统的可扩展性。</p><ul><li><strong>核心逻辑</strong>：允许通过继承、接口实现、SPI等方式扩展功能，而不修改原有核心代码。</li><li><strong>JDK体现</strong>： <ul><li>继承与重写：<code>AbstractList</code>提供通用方法，子类（如<code>ArrayList</code>）可重写方法优化性能。</li><li>SPI机制：JDBC通过<code>ServiceLoader</code>加载第三方数据库驱动，无需修改JDK核心代码。</li><li>接口扩展：<code>List</code>接口新增<code>stream()</code>方法时，通过默认方法（Default Method）兼容旧实现。</li></ul></li></ul><h3 id="_4-泛型与类型安全-编译时检查-消除强转" tabindex="-1">4. <strong>泛型与类型安全：编译时检查，消除强转</strong> <a class="header-anchor" href="#_4-泛型与类型安全-编译时检查-消除强转" aria-label="Permalink to &quot;4. **泛型与类型安全：编译时检查，消除强转**&quot;">​</a></h3><p>泛型是Java 5引入的核心特性，解决了集合框架的类型安全问题。</p><ul><li><strong>核心逻辑</strong>：通过类型参数（如<code>E</code>、<code>K</code>、<code>V</code>）在编译时校验元素类型，避免运行时<code>ClassCastException</code>。</li><li><strong>JDK体现</strong>： <ul><li>集合框架的泛型化：<code>List&lt;String&gt;</code>、<code>Map&lt;Integer, User&gt;</code>等，确保集合元素类型统一。</li><li>泛型方法与通配符：<code>Collections.sort()</code>支持任意类型集合排序，<code>&lt;? extends T&gt;</code>实现协变。</li></ul></li><li><strong>底层平衡</strong>：通过<strong>类型擦除</strong>兼容Java 5之前的代码，泛型信息在运行时被擦除为<code>Object</code>或上界类型。</li></ul><h3 id="_5-分层与模块化-职责单一-复用性高" tabindex="-1">5. <strong>分层与模块化：职责单一，复用性高</strong> <a class="header-anchor" href="#_5-分层与模块化-职责单一-复用性高" aria-label="Permalink to &quot;5. **分层与模块化：职责单一，复用性高**&quot;">​</a></h3><p>JDK将复杂系统拆分为层次分明的模块，每层专注单一职责，提升了代码复用性和可维护性。</p><ul><li><strong>核心逻辑</strong>：上层依赖下层抽象，不依赖具体实现；下层实现上层契约，不影响上层逻辑。</li><li><strong>JDK体现</strong>： <ul><li>集合框架分层：接口层（定义规范）→ 抽象层（实现通用逻辑）→ 实现层（底层存储优化）。</li><li>IO流分层：字节流/字符流（按数据单位分层）、节点流/处理流（按职责分层，装饰器模式）。</li><li>NIO分层：缓冲区（Buffer）、通道（Channel）、选择器（Selector）分离IO操作的不同环节。</li></ul></li></ul><h3 id="_6-异常处理-责任分离-清晰可控" tabindex="-1">6. <strong>异常处理：责任分离，清晰可控</strong> <a class="header-anchor" href="#_6-异常处理-责任分离-清晰可控" aria-label="Permalink to &quot;6. **异常处理：责任分离，清晰可控**&quot;">​</a></h3><p>JDK将异常分为<strong>可检查异常（Checked Exception）和运行时异常（Unchecked Exception）</strong>，明确了错误处理的责任边界。</p><ul><li><strong>核心逻辑</strong>： <ul><li>可检查异常（如<code>IOException</code>）：强制开发者捕获或声明，用于处理可预见的外部错误（如文件不存在）。</li><li>运行时异常（如<code>NullPointerException</code>）：无需强制捕获，用于处理代码逻辑错误（如空指针访问）。</li></ul></li><li><strong>JDK体现</strong>：文件IO操作必须处理<code>IOException</code>，而空指针异常由程序员通过代码逻辑避免。</li></ul><h3 id="_7-设计模式工程化-用成熟模式解决通用问题" tabindex="-1">7. <strong>设计模式工程化：用成熟模式解决通用问题</strong> <a class="header-anchor" href="#_7-设计模式工程化-用成熟模式解决通用问题" aria-label="Permalink to &quot;7. **设计模式工程化：用成熟模式解决通用问题**&quot;">​</a></h3><p>JDK广泛应用了经典设计模式，让代码更优雅、可维护性更高。</p><table tabindex="0"><thead><tr><th>设计模式</th><th>JDK中的典型应用</th></tr></thead><tbody><tr><td>模板方法模式</td><td><code>AbstractList</code>的<code>add()</code>、<code>remove()</code></td></tr><tr><td>装饰器模式</td><td>IO流的处理流（如<code>BufferedReader</code>）</td></tr><tr><td>工厂模式</td><td><code>Calendar.getInstance()</code>、<code>Pattern.compile()</code></td></tr><tr><td>单例模式</td><td><code>Runtime.getRuntime()</code>、<code>System.getSecurityManager()</code></td></tr><tr><td>迭代器模式</td><td><code>Collection.iterator()</code></td></tr></tbody></table><h3 id="_8-性能与兼容性的权衡" tabindex="-1">8. <strong>性能与兼容性的权衡</strong> <a class="header-anchor" href="#_8-性能与兼容性的权衡" aria-label="Permalink to &quot;8. **性能与兼容性的权衡**&quot;">​</a></h3><p>JDK在性能优化和向后兼容之间做了大量平衡，避免激进重构影响现有生态。</p><ul><li><strong>核心逻辑</strong>：在保证兼容性的前提下，逐步优化性能；通过妥协设计（如类型擦除）兼容旧代码。</li><li><strong>JDK体现</strong>： <ul><li>泛型类型擦除：兼容Java 5之前的非泛型代码，但牺牲了运行时泛型信息。</li><li><code>String</code>不可变性：保证线程安全和缓存效率，但带来了字符串拼接的额外开销（通过<code>StringBuilder</code>优化）。</li><li><code>ConcurrentHashMap</code>：用分段锁替代全局锁，兼顾线程安全和并发性能。</li></ul></li></ul><h3 id="_9-工具类与静态方法-高效复用-无状态设计" tabindex="-1">9. <strong>工具类与静态方法：高效复用，无状态设计</strong> <a class="header-anchor" href="#_9-工具类与静态方法-高效复用-无状态设计" aria-label="Permalink to &quot;9. **工具类与静态方法：高效复用，无状态设计**&quot;">​</a></h3><p>JDK提供了大量工具类（如<code>Collections</code>、<code>Arrays</code>、<code>Objects</code>），通过静态方法提供通用功能，避免实例化开销。</p><ul><li><strong>核心逻辑</strong>：工具类专注单一功能，无状态设计，通过静态方法直接调用，提升代码效率。</li><li><strong>JDK体现</strong>：<code>Collections.sort()</code>对集合排序，<code>Arrays.asList()</code>将数组转为列表，<code>Objects.requireNonNull()</code>校验非空。</li></ul><h3 id="_10-并发与线程安全-基础支撑-场景化选择" tabindex="-1">10. <strong>并发与线程安全：基础支撑，场景化选择</strong> <a class="header-anchor" href="#_10-并发与线程安全-基础支撑-场景化选择" aria-label="Permalink to &quot;10. **并发与线程安全：基础支撑，场景化选择**&quot;">​</a></h3><p>JDK提供了完善的多线程编程基础，区分线程安全与非线程安全实现，满足不同场景需求。</p><ul><li><strong>核心逻辑</strong>：通过<code>synchronized</code>、<code>volatile</code>、<code>Concurrent</code>包等机制，支持高并发场景的线程安全。</li><li><strong>JDK体现</strong>： <ul><li>非线程安全：<code>HashMap</code>、<code>ArrayList</code>（性能优先，适合单线程场景）。</li><li>线程安全：<code>Hashtable</code>、<code>Vector</code>（全局锁，性能较低）；<code>ConcurrentHashMap</code>（分段锁，高并发场景）。</li><li>线程协作：<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>等工具类实现线程同步。</li></ul></li></ul><h3 id="总结-jdk设计思想的核心价值" tabindex="-1">总结：JDK设计思想的核心价值 <a class="header-anchor" href="#总结-jdk设计思想的核心价值" aria-label="Permalink to &quot;总结：JDK设计思想的核心价值&quot;">​</a></h3><p>JDK的设计思想本质上是<strong>工程化与生态化的平衡</strong>：</p><ul><li>它通过<strong>分层抽象、接口驱动</strong>保证了代码的可扩展性；</li><li>通过<strong>泛型、异常处理</strong>提升了代码的安全性与可控性；</li><li>通过<strong>跨平台、兼容性</strong>支撑了Java生态的持续发展；</li><li>最终，这些设计思想共同构建了一个<strong>健壮、灵活、高效</strong>的Java开发基础。</li></ul><h2 id="一、泛型基础到原理解析" tabindex="-1">一、泛型基础到原理解析 <a class="header-anchor" href="#一、泛型基础到原理解析" aria-label="Permalink to &quot;一、泛型基础到原理解析&quot;">​</a></h2><h3 id="_1-泛型是什么" tabindex="-1">1 泛型是什么？ <a class="header-anchor" href="#_1-泛型是什么" aria-label="Permalink to &quot;1 泛型是什么？&quot;">​</a></h3><p>泛型是 Java 5 引入的核心特性，它允许我们在定义<strong>类、接口、方法</strong>时使用<strong>类型参数（Type Parameter）</strong>，在实际使用时再指定具体的类型。</p><ul><li>核心价值：<strong>编译时类型安全检查</strong> + <strong>消除强制类型转换</strong> + <strong>大幅提升代码复用性</strong>。</li><li>比如 <code>List&lt;E&gt;</code> 中的 <code>E</code> 就是类型参数，当你写 <code>List&lt;String&gt;</code> 时，<code>E</code> 就被替换为 <code>String</code>，这个列表就只能存字符串了。</li></ul><h3 id="_2-泛型解决了什么问题" tabindex="-1">2 泛型解决了什么问题？ <a class="header-anchor" href="#_2-泛型解决了什么问题" aria-label="Permalink to &quot;2 泛型解决了什么问题？&quot;">​</a></h3><p>在没有泛型的 Java 1.4 及更早版本中，集合只能存储 <code>Object</code> 类型，会带来两个严重问题：</p><h4 id="_1-运行时类型错误" tabindex="-1">1. 运行时类型错误 <a class="header-anchor" href="#_1-运行时类型错误" aria-label="Permalink to &quot;1. 运行时类型错误&quot;">​</a></h4><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无泛型时代的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译不报错，运行时才会出问题</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取出元素时必须强转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (String) list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 运行时抛出 ClassCastException</span></span></code></pre></div><p>泛型的出现让这类错误在<strong>编译阶段</strong>就被发现，而不是等到运行时崩溃。</p><h4 id="_2-冗余的强制类型转换" tabindex="-1">2. 冗余的强制类型转换 <a class="header-anchor" href="#_2-冗余的强制类型转换" aria-label="Permalink to &quot;2. 冗余的强制类型转换&quot;">​</a></h4><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无泛型：每次取元素都要强转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;apple&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String fruit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (String) list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 有泛型：自动推导类型，无需强转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;apple&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String fruit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接得到 String 类型</span></span></code></pre></div><h3 id="_3-泛型的核心使用方式" tabindex="-1">3 泛型的核心使用方式 <a class="header-anchor" href="#_3-泛型的核心使用方式" aria-label="Permalink to &quot;3 泛型的核心使用方式&quot;">​</a></h3><h4 id="_1-泛型类-泛型接口" tabindex="-1">1. 泛型类 / 泛型接口 <a class="header-anchor" href="#_1-泛型类-泛型接口" aria-label="Permalink to &quot;1. 泛型类 / 泛型接口&quot;">​</a></h4><p>在定义类或接口时，用 <code>&lt;类型参数&gt;</code> 声明泛型，类型参数通常用单个大写字母表示：</p><ul><li><code>E</code>：Element（元素，用于集合）</li><li><code>K</code>：Key（键，用于 Map）</li><li><code>V</code>：Value（值，用于 Map）</li><li><code>T</code>：Type（类型，通用）</li><li><code>U</code>/<code>S</code>：辅助类型参数</li></ul><p><strong>示例：自定义泛型类</strong></p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义泛型类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenericBox</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T value;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用泛型类</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GenericBox&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stringBox </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenericBox&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stringBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接得到 String，无需强转</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GenericBox&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; intBox </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GenericBox&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">intBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Integer num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接得到 Integer</span></span></code></pre></div><h4 id="_2-泛型方法" tabindex="-1">2. 泛型方法 <a class="header-anchor" href="#_2-泛型方法" aria-label="Permalink to &quot;2. 泛型方法&quot;">​</a></h4><p>泛型方法是指<strong>方法自己拥有类型参数</strong>，它可以定义在普通类中，也可以定义在泛型类中。</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenericMethodDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 泛型方法：类型参数 &lt;T&gt; 放在返回值前面</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (T element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] strArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;C&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] intArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 调用时自动推导类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(strArray); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// T 被推导为 String</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(intArray);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// T 被推导为 Integer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-通配符-wildcard" tabindex="-1">3. 通配符（Wildcard） <a class="header-anchor" href="#_3-通配符-wildcard" aria-label="Permalink to &quot;3. 通配符（Wildcard）&quot;">​</a></h4><p>通配符用 <code>?</code> 表示，用于处理泛型的<strong>协变与逆变</strong>，是泛型中最灵活也最容易混淆的部分。</p><table tabindex="0"><thead><tr><th>通配符写法</th><th>含义</th><th>适用场景</th></tr></thead><tbody><tr><td><code>&lt;?&gt;</code></td><td>任意类型（无界通配符）</td><td>只读取集合元素，不写入</td></tr><tr><td><code>&lt;? extends T&gt;</code></td><td>上界通配符：只能是 T 或 T 的子类</td><td><strong>生产者场景</strong>：从集合中读取元素（比如 <code>List&lt;? extends Number&gt;</code> 可以接收 <code>List&lt;Integer&gt;</code> 或 <code>List&lt;Double&gt;</code>）</td></tr><tr><td><code>&lt;? super T&gt;</code></td><td>下界通配符：只能是 T 或 T 的父类</td><td><strong>消费者场景</strong>：向集合中写入元素（比如 <code>List&lt;? super Integer&gt;</code> 可以接收 <code>List&lt;Number&gt;</code> 或 <code>List&lt;Object&gt;</code>）</td></tr></tbody></table><p><strong>核心原则：PECS（Producer Extends, Consumer Super）</strong></p><ul><li>如果你的代码是<strong>生产者</strong>（只从集合中取元素）→ 使用 <code>&lt;? extends T&gt;</code></li><li>如果你的代码是<strong>消费者</strong>（只向集合中存元素）→ 使用 <code>&lt;? super T&gt;</code></li><li>如果既存又取 → 不要用通配符，直接用具体泛型类型</li></ul><h3 id="_4-泛型的底层原理-类型擦除" tabindex="-1">4 泛型的底层原理：类型擦除 <a class="header-anchor" href="#_4-泛型的底层原理-类型擦除" aria-label="Permalink to &quot;4 泛型的底层原理：类型擦除&quot;">​</a></h3><p>Java 的泛型是<strong>编译时特性</strong>，在运行时会被“擦除”，这是理解泛型很多特性的关键。</p><h4 id="_1-擦除规则" tabindex="-1">1. 擦除规则 <a class="header-anchor" href="#_1-擦除规则" aria-label="Permalink to &quot;1. 擦除规则&quot;">​</a></h4><ul><li>无边界的泛型参数（如 <code>&lt;T&gt;</code>）会被擦除为 <code>Object</code></li><li>有边界的泛型参数（如 <code>&lt;T extends Number&gt;</code>）会被擦除为它的上界（<code>Number</code>）</li></ul><p><strong>示例：擦除前后对比</strong></p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译前</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenericBox</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后（类型擦除）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenericBox</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_2-擦除带来的影响" tabindex="-1">2. 擦除带来的影响 <a class="header-anchor" href="#_2-擦除带来的影响" aria-label="Permalink to &quot;2. 擦除带来的影响&quot;">​</a></h4><ol><li><strong>运行时无法区分泛型类型</strong><ol><li><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; strList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; intList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(strList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 true</span></span></code></pre></div></li><li><p>因为运行时泛型信息被擦除，两个 <code>List</code> 都被视为 <code>ArrayList</code> 类型。</p></li></ol></li><li><strong>不能创建泛型数组</strong><ol><li><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译报错：泛型数组创建不允许</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;[] listArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div></li><li><p>原因是数组是<strong>协变的</strong>，而泛型是<strong>不变的</strong>，类型擦除会导致运行时类型检查失效。</p></li></ol></li><li><strong>不能用 instanceof 判断泛型类型</strong><ol><li><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译报错</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { ... }</span></span></code></pre></div></li></ol></li></ol><h3 id="_5-泛型的常见误区" tabindex="-1">5 泛型的常见误区 <a class="header-anchor" href="#_5-泛型的常见误区" aria-label="Permalink to &quot;5 泛型的常见误区&quot;">​</a></h3><h4 id="_1-泛型是-协变-的-❌" tabindex="-1">1. 泛型是“协变”的？❌ <a class="header-anchor" href="#_1-泛型是-协变-的-❌" aria-label="Permalink to &quot;1. 泛型是“协变”的？❌&quot;">​</a></h4><p>很多人以为 <code>List&lt;String&gt;</code> 是 <code>List&lt;Object&gt;</code> 的子类，其实不是！</p><p>泛型是<strong>不变的</strong>，<code>List&lt;String&gt;</code> 和 <code>List&lt;Object&gt;</code> 之间没有继承关系。</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; strList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译报错：List&lt;String&gt; 不能赋值给 List&lt;Object&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; objList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strList;</span></span></code></pre></div><p>要实现协变，必须使用上界通配符：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; objList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strList; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 合法</span></span></code></pre></div><h4 id="_2-原始类型-raw-type-可以随便用-❌" tabindex="-1">2. 原始类型（Raw Type）可以随便用？❌ <a class="header-anchor" href="#_2-原始类型-raw-type-可以随便用-❌" aria-label="Permalink to &quot;2. 原始类型（Raw Type）可以随便用？❌&quot;">​</a></h4><p>原始类型是指不带泛型参数的泛型类（如 <code>List</code> 而不是 <code>List&lt;E&gt;</code>），这是为了兼容旧代码而保留的语法。</p><ul><li>不建议使用：会丢失泛型的类型安全检查，回到无泛型时代的问题。</li><li>编译器会给出“unchecked”警告，提示潜在的类型错误。</li></ul><h3 id="_6-泛型最佳实践" tabindex="-1">6 泛型最佳实践 <a class="header-anchor" href="#_6-泛型最佳实践" aria-label="Permalink to &quot;6 泛型最佳实践&quot;">​</a></h3><ol><li><strong>始终使用泛型</strong>：避免原始类型，保证类型安全。</li><li><strong>遵循 PECS 原则</strong>：处理集合时，根据“生产者/消费者”场景选择合适的通配符。</li><li><strong>泛型方法优先于泛型类</strong>：如果只是某个方法需要泛型，不要把整个类都泛型化。</li><li><strong>不要用通配符作为返回类型</strong>：返回值用具体泛型类型，让调用者更清晰。</li><li><strong>合理使用泛型边界</strong>：用 <code>&lt;T extends Number&gt;</code> 限定类型范围，避免无意义的类型传入。</li></ol>`,81)]))}const E=i(l,[["render",e]]);export{g as __pageData,E as default};
